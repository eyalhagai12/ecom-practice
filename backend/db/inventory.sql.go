// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: inventory.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const createInventory = `-- name: CreateInventory :one
INSERT INTO inventory (id, product_id, quantity, location_id) VALUES ($1, $2, $3, $4) RETURNING id, product_id, quantity, location_id, created_at, updated_at, deleted_at
`

func (q *Queries) CreateInventory(ctx context.Context, iD uuid.UUID, productID uuid.UUID, quantity int32, locationID int64) (Inventory, error) {
	row := q.db.QueryRow(ctx, createInventory,
		iD,
		productID,
		quantity,
		locationID,
	)
	var i Inventory
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Quantity,
		&i.LocationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createLocation = `-- name: CreateLocation :one
INSERT INTO location (name, address) VALUES ($1, $2) RETURNING id, name, address
`

func (q *Queries) CreateLocation(ctx context.Context, name string, address string) (Location, error) {
	row := q.db.QueryRow(ctx, createLocation, name, address)
	var i Location
	err := row.Scan(&i.ID, &i.Name, &i.Address)
	return i, err
}

const deleteInventory = `-- name: DeleteInventory :one
UPDATE inventory SET deleted_at = CURRENT_TIMESTAMP WHERE id = $1 RETURNING id, product_id, quantity, location_id, created_at, updated_at, deleted_at
`

func (q *Queries) DeleteInventory(ctx context.Context, id uuid.UUID) (Inventory, error) {
	row := q.db.QueryRow(ctx, deleteInventory, id)
	var i Inventory
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Quantity,
		&i.LocationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getInventoryByID = `-- name: GetInventoryByID :one
SELECT id, product_id, quantity, location_id, created_at, updated_at, deleted_at FROM inventory WHERE id = $1
`

func (q *Queries) GetInventoryByID(ctx context.Context, id uuid.UUID) (Inventory, error) {
	row := q.db.QueryRow(ctx, getInventoryByID, id)
	var i Inventory
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Quantity,
		&i.LocationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getProductInventories = `-- name: GetProductInventories :many
SELECT id, product_id, quantity, location_id, created_at, updated_at, deleted_at FROM inventory WHERE product_id = $1
`

func (q *Queries) GetProductInventories(ctx context.Context, productID uuid.UUID) ([]Inventory, error) {
	rows, err := q.db.Query(ctx, getProductInventories, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Inventory
	for rows.Next() {
		var i Inventory
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Quantity,
			&i.LocationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInventory = `-- name: UpdateInventory :one
UPDATE inventory SET quantity = $2 WHERE id = $1 RETURNING id, product_id, quantity, location_id, created_at, updated_at, deleted_at
`

func (q *Queries) UpdateInventory(ctx context.Context, iD uuid.UUID, quantity int32) (Inventory, error) {
	row := q.db.QueryRow(ctx, updateInventory, iD, quantity)
	var i Inventory
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Quantity,
		&i.LocationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
